#!/bin/sh /etc/rc.common

USE_PROCD=1
START=99
STOP=90 # 确保在防火墙重载前停止

NAME="UAmask"
PROG="/usr/bin/$NAME"
PID_FILE="/var/run/$NAME.pid"
FW_CONFIG_NAME="UAmask" # 防火墙 UCI 规则的名称
NFT_PATH="/tmp/UAmask_rules.nft" # .nft 文件的路径 (使用 /tmp/)

# 仅清理规则和 uci，不重载
unset_firewall_rules() {
    rm -f "${NFT_PATH}" # 清理生成的规则文件
    uci -q delete firewall.${FW_CONFIG_NAME}
    uci commit firewall
}

# 清理防火墙规则并重载
unset_firewall() {
    logger -t "$NAME" "Removing firewall rules..."
    unset_firewall_rules
    nft delete chain inet fw4 UAmask_prerouting_before 2>/dev/null || true
    nft delete chain inet fw4 UAmask_output_after 2>/dev/null || true
    fw4 reload >/dev/null 2>&1
    logger -t "$NAME" "Firewall rules removed."
}

# 自动管理防火墙规则
set_firewall() {
    # 1. 确保旧规则被彻底清除
    unset_firewall_rules

    # 2. 从 UCI 读取配置
    config_load "$NAME"
    local port
    local iface_list
    local bypass_gid
    local bypass_ports_list
    local bypass_ips_list
    local force_replace
    local proxy_host

    config_get port "main" "port" "12032"
    config_get iface_list "main" "iface" "br-lan"
    config_get bypass_gid "main" "bypass_gid" "65533"
    config_get bypass_ports_list "main" "bypass_ports" ""
    config_get bypass_ips_list "main" "bypass_ips" ""
    config_get_bool proxy_host "main" "proxy_host" ""

    # 3. 格式化接口
    local nft_ifaces
    set -- $iface_list
    if [ "$#" -eq 1 ]; then
        nft_ifaces="\"$1\"" # 单个接口
    else
        nft_ifaces="{ $(echo "$iface_list" | sed -e 's/ /", "/g' -e 's/^/"/' -e 's/$/"/') }" # 多个接口
    fi

    # 4. 格式化豁免 IPs
    local nft_ips_rule
    if [ -n "$bypass_ips_list" ]; then
        local nft_ips
        nft_ips="{ $(echo "$bypass_ips_list" | sed -e 's/ /, /g') }"
        nft_ips_rule="ip daddr != $nft_ips \\"
    else
        nft_ips_rule="# No bypass IPs configured"
    fi

    # 5. 格式化豁免 Ports
    local nft_ports_rule
    if [ -n "$bypass_ports_list" ]; then
        local nft_ports
        nft_ports="{ $(echo "$bypass_ports_list" | sed -e 's/ /, /g') }"
        nft_ports_rule="tcp dport != $nft_ports \\"
    else
        nft_ports_rule="# No bypass ports configured"
    fi

# 6. 动态写入 .nft 文件
    cat > "${NFT_PATH}" << EOF
chain UAmask_prerouting_before {
    type nat hook prerouting priority dstnat - 1;
iifname $nft_ifaces \\
    ip protocol tcp \\
    # 豁免局域网、环回、保留地址等
    $nft_ips_rule
    # 豁免端口
    $nft_ports_rule
    redirect to :$port
}

EOF

    if [ "$proxy_host" = "1" ]; then
        cat >> "${NFT_PATH}" << EOF
chain UAmask_output_after {
    type nat hook output priority -100;
ip protocol tcp \\
    # 豁免局域网、环回、保留地址等
    $nft_ips_rule
    # 豁免端口
    $nft_ports_rule
    # 豁免 UAmask 自己的流量 
    # 同时豁免 OpenClash 的流量 (GID 65534)，防止循环
    meta skgid != { $bypass_gid, 65534 } \\
    redirect to :$port
}

EOF
        logger -t "$NAME" "proxy_host is enabled. Added UAmask_output_after chain."
    else
        logger -t "$NAME" "proxy_host is disabled. Skipping UAmask_output_after chain."
    fi
    logger -t "$NAME" "Generated nftables rules at ${NFT_PATH}"
    # 7. 注册防火墙规则
    uci set firewall.${FW_CONFIG_NAME}="include"
    uci set firewall.${FW_CONFIG_NAME}.type="nftables"
    uci set firewall.${FW_CONFIG_NAME}.path="${NFT_PATH}"
    uci set firewall.${FW_CONFIG_NAME}.enabled="1"
    uci commit firewall
    nft delete chain inet fw4 UAmask_prerouting_before 2>/dev/null || true
    nft delete chain inet fw4 UAmask_output_after 2>/dev/null || true
    fw4 reload >/dev/null 2>&1
    logger -t "$NAME" "Firewall rules applied."

}

# 检查并创建专用组
setup_group() {
    config_load "$NAME"
    local bypass_gid
    config_get bypass_gid "main" "bypass_gid" "65533"

    if ! grep -q ":$bypass_gid:" /etc/group; then
        echo "UAmask:x:$bypass_gid:" >> /etc/group
    fi
}

start_service() {
    config_load "$NAME"

    local enabled
    config_get_bool enabled "enabled" "enabled" "0"
    if [ "$enabled" -ne "1" ]; then
        return 1
    fi

    local proxy_host
    config_get_bool proxy_host "main" "proxy_host" "0"

    if [ "$proxy_host" = "1" ]; then
        setup_group 
    fi

    local port ua log_level log_file whitelist
    config_get port "main" "port" "12032"
    config_get ua "main" "ua" "FFF"
    config_get log_level "main" "log_level" "info"
    config_get log_file "main" "log_file" "/tmp/UAmask/UAmask.log"
    config_get whitelist "main" "whitelist" ""
    
    mkdir -p "$(dirname "$log_file")"

    procd_open_instance "$NAME"
    procd_set_param command "$PROG"

    #  使用 append_param 逐个添加参数
    if [ "$proxy_host" = "1" ]; then
        # 仅当 proxy_host 启用时，才以特定组运行
        procd_set_param group "UAmask" 
        logger -t "$NAME" "Running as group 'UAmask' for host proxying."
    else
        logger -t "$NAME" "Running as default user (proxy_host is disabled)."
    fi

    #  添加基础参数
    procd_append_param command -port "$port"
    procd_append_param command -u "$ua"
    procd_append_param command -loglevel "$log_level"
    procd_append_param command -w "$whitelist"
    [ -n "$log_file" ] && procd_append_param command -log "$log_file"

    local operating_profile
    config_get operating_profile "main" "operating_profile" "high_throughput"

    local cache_size buffer_size pool_size gogc_value

    case "$operating_profile" in
        Low)
            logger -t "$NAME" "Starting in LOW mode."
            cache_size=2000
            buffer_size=8192
            pool_size=200
            ;;
        
        Medium)
            logger -t "$NAME" "Starting in Medium mode."
            cache_size=3000
            buffer_size=8192
            pool_size=500
            ;;

        High)
            logger -t "$NAME" "Starting in High Throughput mode."
            cache_size=5000
            buffer_size=8192
            pool_size=1000
            ;;

        custom)
            config_get cache_size "main" "cache_size" "2000"
            config_get buffer_size "main" "buffer_size" "8192"
            config_get pool_size "main" "pool_size" "0"
            config_get gogc_value "main" "gogc_value" "100"
            logger -t "$NAME" "Starting in Custom mode: cache_size=$cache_size, buffer_size=$buffer_size, pool_size=$pool_size, GOGC=$gogc_value."
            ;;

        *)
            logger -t "$NAME" "Starting in LOW mode."
            cache_size=2000
            buffer_size=4096
            pool_size=200
            ;;
    esac

    # 统一应用参数
    procd_append_param command -cache-size "$cache_size"
    procd_append_param command -buffer-size "$buffer_size"
    procd_append_param command -p "$pool_size"

    # 仅当 gogc_value 不是默认值 100 时才设置 GOGC
    if [ "$gogc_value" != "100" ]; then
        procd_set_param env "GOGC=$gogc_value"
    fi

    #  处理“匹配规则”
    local match_mode
    config_get match_mode "main" "match_mode" "keywords"
    
    case "$match_mode" in
        "keywords")
            local keywords
            config_get keywords "main" "keywords" "iPhone,iPad,Android,Macintosh,Windows"
            logger -t "$NAME" "Using keyword matching mode."
            procd_append_param command -keywords "$keywords"
            ;;
        "regex")
            local ua_regex replace_method
            config_get ua_regex "main" "ua_regex" "(iPhone|iPad|Android|Macintosh|Windows|Linux)"
            config_get replace_method "main" "replace_method" "full"
            
            logger -t "$NAME" "Using regex matching mode."
            procd_append_param command -enable-regex
            procd_append_param command -r "$ua_regex"

            if [ "$replace_method" = "partial" ]; then
                logger -t "$NAME" "Partial replacement enabled."
                procd_append_param command -s
            else
                logger -t "$NAME" "Full replacement enabled for regex match."
            fi
            ;;
        "all")
            logger -t "$NAME" "Using modify-all (force) mode."
            procd_append_param command -force
            ;;
    esac

    #  设置其他 procd 参数
    procd_set_param respawn    
    procd_set_param stdout 1   
    procd_set_param stderr 1  

    procd_close_instance
    #  启动后自动设置防火墙
    set_firewall
}

stop_service() {
    logger -t "$NAME" "Stopping $NAME..."
    # 停止服务时自动清理防火墙
    unset_firewall
    # procd 会自动使用 pidfile 停止 start-stop-daemon
}

service_triggers() {
    procd_add_reload_trigger "$NAME"
}