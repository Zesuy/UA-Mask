#!/bin/sh /etc/rc.common

USE_PROCD=1
START=99
STOP=90 # 确保在防火墙重载前停止

NAME="ua3f-tproxy"
PROG="/usr/bin/$NAME"
PID_FILE="/var/run/$NAME.pid"


IPT="iptables"
CHAIN_PREROUTING="ua3f_prerouting"
CHAIN_OUTPUT="ua3f_output"

# 清理防火墙规则并重载
unset_firewall() {
    logger -t "$NAME" "Removing firewall rules (iptables)..."
    
    # 循环尝试删除跳转规则，直到成功或失败
    while $IPT -t nat -D PREROUTING -j $CHAIN_PREROUTING 2>/dev/null; do :; done
    while $IPT -t nat -D OUTPUT -j $CHAIN_OUTPUT 2>/dev/null; do :; done


    $IPT -t nat -F $CHAIN_PREROUTING 2>/dev/null || true
    $IPT -t nat -X $CHAIN_PREROUTING 2>/dev/null || true
    
    $IPT -t nat -F $CHAIN_OUTPUT 2>/dev/null || true
    $IPT -t nat -X $CHAIN_OUTPUT 2>/dev/null || true
    

    /etc/init.d/firewall reload >/dev/null 2>&1
    logger -t "$NAME" "Firewall rules removed."
}


set_firewall() {
    # 1. 确保旧规则被彻底清除
    unset_firewall

    # 2. 从 UCI 读取配置 (此部分不变)
    config_load "$NAME"
    local port
    local iface_list
    local bypass_gid
    local bypass_ports_list
    local bypass_ips_list
    local proxy_host

    config_get port "main" "port" "12032"
    config_get iface_list "main" "iface" "br-lan"
    config_get bypass_gid "main" "bypass_gid" "65533"
    config_get bypass_ports_list "main" "bypass_ports" ""
    config_get bypass_ips_list "main" "bypass_ips" ""
    config_get_bool proxy_host "main" "proxy_host" ""

    # --- IPTABLES 规则设置 ---

    # 3. 创建自定义链
    $IPT -t nat -N $CHAIN_PREROUTING
    $IPT -t nat -N $CHAIN_OUTPUT

    # 4. 填充 PREROUTING 链
    for iface in $iface_list; do
        for ip in $bypass_ips_list; do
            $IPT -t nat -A $CHAIN_PREROUTING -i "$iface" -p tcp -d "$ip" -j RETURN
        done
        if [ -n "$bypass_ports_list" ]; then
            local ipt_ports=$(echo "$bypass_ports_list" | sed 's/ /,/g')
            $IPT -t nat -A $CHAIN_PREROUTING -i "$iface" -p tcp -m multiport --dports "$ipt_ports" -j RETURN
        fi
        # 将剩余的 TCP 流量重定向到代理端口
        $IPT -t nat -A $CHAIN_PREROUTING -i "$iface" -p tcp -j REDIRECT --to-port "$port"
    done

    # 5. OUTPUT 链处理本机流量
    if [ "$proxy_host" = "1" ]; then
        # 豁免 ua3f-tproxy 自己的流量 (通过 GID)
        $IPT -t nat -A $CHAIN_OUTPUT -p tcp -m owner --gid-owner "$bypass_gid" -j RETURN
        # 同时豁免 OpenClash 的流量 (GID 65534)，防止循环
        $IPT -t nat -A $CHAIN_OUTPUT -p tcp -m owner --gid-owner "65534" -j RETURN
        
        # 豁免指定的目标 IP
        for ip in $bypass_ips_list; do
            $IPT -t nat -A $CHAIN_OUTPUT -p tcp -d "$ip" -j RETURN
        done
        
        # 豁免指定的端口
        if [ -n "$bypass_ports_list" ]; then
            local ipt_ports=$(echo "$bypass_ports_list" | sed 's/ /,/g')
            $IPT -t nat -A $CHAIN_OUTPUT -p tcp -m multiport --dports "$ipt_ports" -j RETURN
        fi

        # 将剩余的 TCP 流量重定向到代理端口
        $IPT -t nat -A $CHAIN_OUTPUT -p tcp -j REDIRECT --to-port "$port"
        
        # 将自定义 OUTPUT 链挂载到内置的 OUTPUT 链
        $IPT -t nat -I OUTPUT 1 -j $CHAIN_OUTPUT
        logger -t "$NAME" "proxy_host is enabled. Added iptables rules for OUTPUT chain."
    else
        logger -t "$NAME" "proxy_host is disabled. Skipping OUTPUT chain rules."
    fi

    # 6. 将自定义 PREROUTING 链挂载到内置的 PREROUTING 链
    $IPT -t nat -I PREROUTING 1 -j $CHAIN_PREROUTING
    
    logger -t "$NAME" "Firewall rules (iptables) applied."
}

# 检查并创建专用组
setup_group() {
    config_load "$NAME"
    local bypass_gid
    config_get bypass_gid "main" "bypass_gid" "65533"

    if ! grep -q ":$bypass_gid:" /etc/group; then
        echo "ua3f-tproxy:x:$bypass_gid:" >> /etc/group
    fi
}

# 服务启动逻辑
start_service() {
    config_load "$NAME"

    local enabled
    config_get_bool enabled "enabled" "enabled" "0"
    if [ "$enabled" -ne "1" ]; then
        return 1
    fi

    local proxy_host
    config_get_bool proxy_host "main" "proxy_host" "0"

    if [ "$proxy_host" = "1" ]; then
        setup_group 
    fi

    local port ua log_level log_file whitelist
    config_get port "main" "port" "12032"
    config_get ua "main" "ua" "FFF"
    config_get log_level "main" "log_level" "info"
    config_get log_file "main" "log_file" "/tmp/ua3f-tproxy/ua3f-tproxy.log"
    config_get whitelist "main" "whitelist" ""
    
    mkdir -p "$(dirname "$log_file")"

    procd_open_instance "$NAME"
    procd_set_param command "$PROG"

    #  使用 append_param 逐个添加参数
    if [ "$proxy_host" = "1" ]; then
        # 仅当 proxy_host 启用时，才以特定组运行
        procd_set_param group "ua3f-tproxy" 
        logger -t "$NAME" "Running as group 'ua3f-tproxy' for host proxying."
    else
        logger -t "$NAME" "Running as default user (proxy_host is disabled)."
    fi

    #  添加基础参数
    procd_append_param command -port "$port"
    procd_append_param command -u "$ua"
    procd_append_param command -loglevel "$log_level"
    procd_append_param command -w "$whitelist"
    [ -n "$log_file" ] && procd_append_param command -log "$log_file"

    #  处理“运行模式”
    local operating_profile
    config_get operating_profile "main" "operating_profile" "low_memory"
    if [ "$operating_profile" = "low_memory" ];
    then
        logger -t "$NAME" "Starting in Low-Memory mode."
        # 为 Go 程序传递性能调优参数
        procd_append_param command -cache-size 200
        procd_append_param command -buffer-size 4096
    else
        # 默认为 high_throughput
        logger -t "$NAME" "Starting in High-Throughput mode."
        # 使用 Go 程序的默认值或更大的值
        procd_append_param command -cache-size 1000
        procd_append_param command -buffer-size 8192
    fi

    #  处理“匹配规则”
    local match_mode
    config_get match_mode "main" "match_mode" "keywords"
    
    case "$match_mode" in
        "keywords")
            local keywords
            config_get keywords "main" "keywords" "iPhone,iPad,Android,Macintosh,Windows"
            logger -t "$NAME" "Using keyword matching mode."
            procd_append_param command -keywords "$keywords"
            ;;
        "regex")
            local ua_regex replace_method
            config_get ua_regex "main" "ua_regex" "(iPhone|iPad|Android|Macintosh|Windows|Linux)"
            config_get replace_method "main" "replace_method" "full"
            
            logger -t "$NAME" "Using regex matching mode."
            procd_append_param command -enable-regex
            procd_append_param command -r "$ua_regex"

            if [ "$replace_method" = "partial" ]; then
                logger -t "$NAME" "Partial replacement enabled."
                procd_append_param command -s
            else
                logger -t "$NAME" "Full replacement enabled for regex match."
            fi
            ;;
        "all")
            logger -t "$NAME" "Using modify-all (force) mode."
            procd_append_param command -force
            ;;
    esac

    #  设置其他 procd 参数
    procd_set_param respawn    
    procd_set_param stdout 1   
    procd_set_param stderr 1  

    procd_close_instance
    #  启动后自动设置防火墙
    set_firewall
}
# 服务停止逻辑 (不变)
stop_service() {
    logger -t "$NAME" "Stopping $NAME..."
    # 停止服务时自动清理防火墙
    unset_firewall
}

service_triggers() {
    procd_add_reload_trigger "$NAME"
}
