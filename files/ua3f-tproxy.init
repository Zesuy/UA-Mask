#!/bin/sh /etc/rc.common

USE_PROCD=1
START=99
STOP=90 # 确保在防火墙重载前停止

NAME="ua3f-tproxy"
PROG="/usr/bin/$NAME"
PID_FILE="/var/run/$NAME.pid"
FW_CONFIG_NAME="ua3f_tproxy" # 防火墙 UCI 规则的名称
NFT_PATH="/tmp/ua3f_rules.nft" # .nft 文件的路径 (使用 /tmp/)

# 仅清理规则和 uci，不重载
unset_firewall_rules() {
    rm -f "${NFT_PATH}" # 清理生成的规则文件
    uci -q delete firewall.${FW_CONFIG_NAME}
    uci commit firewall
}

# 清理防火墙规则并重载
unset_firewall() {
    logger -t "$NAME" "Removing firewall rules..."
    unset_firewall_rules
    nft delete chain inet fw4 ua3f_prerouting_before 2>/dev/null || true
    nft delete chain inet fw4 ua3f_output_after 2>/dev/null || true
    fw4 reload >/dev/null 2>&1
    logger -t "$NAME" "Firewall rules removed."
}

# 自动管理防火墙规则
set_firewall() {
    # 1. 确保旧规则被彻底清除
    unset_firewall_rules

    # 2. 从 UCI 读取配置
    config_load "$NAME"
    local port
    local iface_list
    local bypass_gid
    local bypass_ports_list
    local bypass_ips_list
    local force_replace
    local proxy_host

    config_get port "main" "port" "12032"
    config_get iface_list "main" "iface" "br-lan"
    config_get bypass_gid "main" "bypass_gid" "65533"
    config_get bypass_ports_list "main" "bypass_ports" ""
    config_get bypass_ips_list "main" "bypass_ips" ""
    config_get_bool proxy_host "main" "proxy_host" ""

    # 3. 格式化接口
    local nft_ifaces
    set -- $iface_list
    if [ "$#" -eq 1 ]; then
        nft_ifaces="\"$1\"" # 单个接口
    else
        nft_ifaces="{ $(echo "$iface_list" | sed -e 's/ /", "/g' -e 's/^/"/' -e 's/$/"/') }" # 多个接口
    fi

    # 4. 格式化豁免 IPs
    local nft_ips_rule
    if [ -n "$bypass_ips_list" ]; then
        local nft_ips
        nft_ips="{ $(echo "$bypass_ips_list" | sed -e 's/ /, /g') }"
        nft_ips_rule="ip daddr != $nft_ips \\"
    else
        nft_ips_rule="# No bypass IPs configured"
    fi

    # 5. 格式化豁免 Ports
    local nft_ports_rule
    if [ -n "$bypass_ports_list" ]; then
        local nft_ports
        nft_ports="{ $(echo "$bypass_ports_list" | sed -e 's/ /, /g') }"
        nft_ports_rule="tcp dport != $nft_ports \\"
    else
        nft_ports_rule="# No bypass ports configured"
    fi

# 6. 动态写入 .nft 文件
    cat > "${NFT_PATH}" << EOF
chain ua3f_prerouting_before {
    type nat hook prerouting priority dstnat - 1;
iifname $nft_ifaces \\
    ip protocol tcp \\
    # 豁免局域网、环回、保留地址等
    $nft_ips_rule
    # 豁免端口
    $nft_ports_rule
    redirect to :$port
}

EOF

    if [ "$proxy_host" = "1" ]; then
        cat >> "${NFT_PATH}" << EOF
chain ua3f_output_after {
    type nat hook output priority -100;
ip protocol tcp \\
    # 豁免局域网、环回、保留地址等
    $nft_ips_rule
    # 豁免端口
    $nft_ports_rule
    # 豁免 ua3f-tproxy 自己的流量 
    # 同时豁免 OpenClash 的流量 (GID 65534)，防止循环
    meta skgid != { $bypass_gid, 65534 } \\
    redirect to :$port
}

EOF
        logger -t "$NAME" "proxy_host is enabled. Added ua3f_output_after chain."
    else
        logger -t "$NAME" "proxy_host is disabled. Skipping ua3f_output_after chain."
    fi
    logger -t "$NAME" "Generated nftables rules at ${NFT_PATH}"
    # 7. 注册防火墙规则
    uci set firewall.${FW_CONFIG_NAME}="include"
    uci set firewall.${FW_CONFIG_NAME}.type="nftables"
    uci set firewall.${FW_CONFIG_NAME}.path="${NFT_PATH}"
    uci set firewall.${FW_CONFIG_NAME}.enabled="1"
    uci commit firewall
    nft delete chain inet fw4 ua3f_prerouting_before 2>/dev/null || true
    nft delete chain inet fw4 ua3f_output_after 2>/dev/null || true
    fw4 reload >/dev/null 2>&1
    logger -t "$NAME" "Firewall rules applied."

}

# 检查并创建专用组
setup_group() {
    config_load "$NAME"
    local bypass_gid
    config_get bypass_gid "main" "bypass_gid" "65533"

    if ! grep -q ":$bypass_gid:" /etc/group; then
        echo "ua3f-tproxy:x:$bypass_gid:" >> /etc/group
    fi
}

start_service() {
    config_load "$NAME"

    local enabled
    config_get_bool enabled "enabled" "enabled" "0"
    if [ "$enabled" -ne "1" ];
    then
        return 1
    fi

    local proxy_host
    config_get_bool proxy_host "main" "proxy_host" "0"

    if [ "$proxy_host" = "1" ]; then
        # 1. 启用代理本机时确保组存在
        setup_group 
    fi
    # 2. 读取 procd 启动所需的配置
    local port
    local ua
    local log_level
    
    config_get port "main" "port" "12032"
    config_get ua "main" "ua" "FFF"
    config_get log_level "main" "log_level" "debug"
    config_get ua_regex "main" "ua_regex" "(iPhone|iPad|Android|Macintosh|Windows|Linux)"
    config_get log_file "main" "log_file" "/tmp/ua3f-tproxy/ua3f-tproxy.log"
    mkdir -p /tmp/ua3f-tproxy

    local ua_mode
    local force_replace
    local partial_replace
    config_get ua_mode "main" "ua_mode" "smart_full"
    if [ "$ua_mode" = "smart_full" ]; then
        force_replace="0"
        partial_replace="0"
    elif [ "$ua_mode" = "smart_partial" ]; then
        force_replace="0"
        partial_replace="1"
    elif [ "$ua_mode" = "force_full" ]; then
        force_replace="1"
        partial_replace="0"
    else
        force_replace="0"
        partial_replace="0"
    fi

    # 4. 启动 procd 实例
    procd_open_instance "$NAME"
    procd_set_param command "$PROG"

    # 5. 使用 append_param 逐个添加参数
    if [ "$proxy_host" = "1" ]; then
        # 仅当 proxy_host 启用时，才以特定组运行
        procd_set_param group "ua3f-tproxy" 
        logger -t "$NAME" "Running as group 'ua3f-tproxy' for host proxying."
    else
        logger -t "$NAME" "Running as default user (proxy_host is disabled)."
    fi
    procd_append_param command -port "$port"
    procd_append_param command -ua "$ua"
    procd_append_param command -loglevel "$log_level"
    procd_append_param command -r "$ua_regex"
    [ -n "$log_file" ] && procd_append_param command -log "$log_file"
    
    if [ "$force_replace" = "1" ]; then
        # 如果启用，则忽略 -s 标志，因为 Go 程序会优先使用 -force
        procd_append_param command -force
        logger -t "$NAME" "Starting with -force enabled. Partial replace (-s) will be ignored."
    elif [ "$partial_replace" = "1" ]; then
        # 仅在 -force 未启用时，才添加 -s 标志
        procd_append_param command -s
        logger -t "$NAME" "Starting with partial replace (-s) enabled."
    else
        logger -t "$NAME" "Starting with default (full) replace mode."
    fi

    # 7. 设置其他 procd 参数
    procd_set_param respawn    
    procd_set_param stdout 1   
    procd_set_param stderr 1  

    procd_close_instance
    # 5. 启动后自动设置防火墙
    set_firewall
}

stop_service() {
    logger -t "$NAME" "Stopping $NAME..."
    # 停止服务时自动清理防火墙
    unset_firewall
    # procd 会自动使用 pidfile 停止 start-stop-daemon
}

service_triggers() {
    procd_add_reload_trigger "$NAME"
}