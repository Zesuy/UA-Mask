#!/bin/sh /etc/rc.common

USE_PROCD=1
START=99
STOP=90 # 确保在防火墙重载前停止

NAME="ua3f-tproxy"
PROG="/usr/bin/$NAME"
PID_FILE="/var/run/$NAME.pid"
FW_CONFIG_NAME="ua3f_tproxy" # 防火墙 UCI 规则的名称
NFT_PATH="/tmp/ua3f_rules.nft" # .nft 文件的路径 (使用 /tmp/)

# 仅清理规则和 uci，不重载
unset_firewall_rules() {
    rm -f "${NFT_PATH}" # 清理生成的规则文件
    uci -q delete firewall.${FW_CONFIG_NAME}
    uci commit firewall
}

# 清理防火墙规则并重载
unset_firewall() {
    unset_firewall_rules
    # 兼容 fw3 和 fw4
    nft delete chain inet fw4 ua3f_prerouting_after 2>/dev/null || true
    nft delete chain inet fw4 ua3f_output_after 2>/dev/null || true
    fw4 reload >/dev/null 2>&1
}

# 自动管理防火墙规则
set_firewall() {
    # 1. 确保旧规则被彻底清除
    unset_firewall_rules

    # 2. 从 UCI 读取配置
    config_load "$NAME"
    local port
    local iface_list
    local bypass_gid
    local bypass_ports_list
    local bypass_ips_list

    config_get port "main" "port" "12032"
    config_get iface_list "main" "iface" "br-lan"
    config_get bypass_gid "main" "bypass_gid" "65533"
    config_get bypass_ports_list "main" "bypass_ports" ""
    config_get bypass_ips_list "main" "bypass_ips" ""

    # 3. 格式化接口
    local nft_ifaces
    set -- $iface_list
    if [ "$#" -eq 1 ]; then
        nft_ifaces="\"$1\"" # 单个接口
    else
        nft_ifaces="{ $(echo "$iface_list" | sed -e 's/ /", "/g' -e 's/^/"/' -e 's/$/"/') }" # 多个接口
    fi

    # 4. 格式化豁免 IPs
    local nft_ips_rule
    if [ -n "$bypass_ips_list" ]; then
        local nft_ips
        nft_ips="{ $(echo "$bypass_ips_list" | sed -e 's/ /, /g') }"
        nft_ips_rule="ip daddr != $nft_ips \\"
    else
        nft_ips_rule="# No bypass IPs configured"
    fi

    # 5. 格式化豁免 Ports
    local nft_ports_rule
    if [ -n "$bypass_ports_list" ]; then
        local nft_ports
        nft_ports="{ $(echo "$bypass_ports_list" | sed -e 's/ /, /g') }"
        nft_ports_rule="tcp dport != $nft_ports \\"
    else
        nft_ports_rule="# No bypass ports configured"
    fi

# 6. 动态写入 .nft 文件
    cat > "${NFT_PATH}" << EOF
chain ua3f_prerouting_after {
    # 优先级必须低于 OpenClash (dstnat / -100)，例如 -101
    type nat hook prerouting priority dstnat - 1;
    iifname $nft_ifaces \\
    ip protocol tcp \\
    # 豁免局域网、环回、保留地址等
    $nft_ips_rule
    # 豁免端口
    $nft_ports_rule
    redirect to :$port
}

chain ua3f_output_after {
    type nat hook output priority -100;
    ip protocol tcp \\
    # 豁免局域网、环回、保留地址等
    $nft_ips_rule
    # 豁免端口
    $nft_ports_rule
    # 豁免 ua3f-tproxy 自己的流量 
    # 同时豁免 OpenClash 的流量 (GID 65534)，防止循环
    meta skgid != { $bypass_gid, 65534 } \\
    redirect to :$port
}

EOF

EOF

    # 7. 注册防火墙规则
    uci set firewall.${FW_CONFIG_NAME}="include"
    uci set firewall.${FW_CONFIG_NAME}.type="nftables"
    uci set firewall.${FW_CONFIG_NAME}.path="${NFT_PATH}"
    uci set firewall.${FW_CONFIG_NAME}.enabled="1"
    uci commit firewall
    # 兼容 fw3 和 fw4
    nft delete chain inet fw4 ua3f_prerouting_after 2>/dev/null || true
    nft delete chain inet fw4 ua3f_output_after 2>/dev/null || true
    fw4 reload >/dev/null 2>&1

}

# 检查并创建专用组
setup_group() {
    config_load "$NAME"
    local bypass_gid
    config_get bypass_gid "main" "bypass_gid" "65533"

    if ! grep -q ":$bypass_gid:" /etc/group; then
        echo "ua3f-tproxy:x:$bypass_gid:" >> /etc/group
    fi
}

start_service() {
    config_load "$NAME"

    local enabled
    config_get_bool enabled "enabled" "enabled" "0"
    if [ "$enabled" -ne "1" ];
    then
        return 1
    fi

    # 1. 确保组存在
    setup_group

    # 2. 自动设置防火墙
    set_firewall

    local port
    local ua
    local log_level
    
    config_get port "main" "port" "12032"
    config_get ua "main" "ua" "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36"
    config_get log_level "main" "log_level" "info"

    procd_open_instance "$NAME"
    
    procd_set_param command $PROG \
        -port $port \
        -ua "$ua" \
        -loglevel $log_level
    procd_set_param group "ua3f-tproxy"
    # 4. 告诉 procd PID 文件的位置，以便它可以正确地停止/重启
    procd_set_param pidfile $PID_FILE
    
    procd_set_param respawn
    

    procd_set_param stdout 1 
    procd_set_param stderr 1 

    procd_close_instance
}

stop_service() {
    # 停止服务时自动清理防火墙
    unset_firewall
    # procd 会自动使用 pidfile 停止 start-stop-daemon
}

service_triggers() {
    procd_add_reload_trigger "$NAME"
    procd_add_reload_trigger "firewall" # 监听防火墙重载
}